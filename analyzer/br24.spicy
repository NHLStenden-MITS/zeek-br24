# TODO: Define your analyzer here.

module BR24;

import spicy;

#public type frame_header = unit {
#    payload: bytes &eod;
#
#};

type reg_number = enum { 
    radar_ops = 1,  # TODO: change that to a name similar to wireshark
    zoom_level = 3, 
    bearing_alignment = 5,
    filters_and_preprocessing = 6,
    interference_rejection = 8,
    target_expansion = 9,
    target_boost = 10,
    local_interference_filter = 14,
    scan_speed = 15,
    noise_rejection = 33,
    target_separation = 34,
    doppler = 35,
    antenna_height = 48,
    keep_alive = 160
};

type reg_command = enum {
    read = 194,
    write = 193
};

type radar_status = enum {
    standby = 1,
    transmit = 2,
    waking_up = 3
};

public type br24_reg = unit {
    %port = 6680/udp &originator;
   
    # register : bytes &size=(1);
    register : uint8 &byte-order=spicy::ByteOrder::Little &convert=reg_number($$);
    command : uint8 &byte-order=spicy::ByteOrder::Little &convert=reg_command($$);
    data : bytes &eod;

    on %init {
        print "Starting REG";
    }

    on %done {
        print self;
    }
};

public type br24_img = unit {
    %port = 6678/udp &originator;

    hdr : img_header;

    : scanline[];

    on %init {
        print "Starting IMG";
    }

    on %done {
        # print self;
    }
};

type img_header = unit {
    #%byte-order = spicy::ByteOrder::Little;
    
    start_marker: bytes &size=(5);
    scanlines_no:   uint8 &byte-order=spicy::ByteOrder::Little;
    scanline_size:   uint16 &byte-order=spicy::ByteOrder::Little;

    # NOTE: Just testing for now
    # : void &size=(17160 - 7);

    # payload: bytes &eod;

    on %init {
        print "Starting HEADER";
    }

    on %done {
        # print self;
        print self.start_marker;
        print self.scanlines_no;
        print self.scanline_size;
    }
};

type scanline = unit {
    #%byte-order = spicy::ByteOrder::Little;
    
    scanline_hdr : scanline_header;
    scanline_pixels : bytes &size=(512);

    on %init {
        print "Starting Scanline";
    }

    on %done {
        # print self;
    }
};

type scanline_header = unit {
        
    scanline_header_len:   uint8 &byte-order=spicy::ByteOrder::Little;
    status:   uint8 &byte-order=spicy::ByteOrder::Little;
    scanline_counter:   uint16 &byte-order=spicy::ByteOrder::Little;
    marking:   bytes &size=(4);
    angle:   uint16 &byte-order=spicy::ByteOrder::Little;
    heading:   uint16 &byte-order=spicy::ByteOrder::Little;
    range:   uint16 &byte-order=spicy::ByteOrder::Little;
    unknown_1:   bytes &size=(10);

    on %init {
        print "Starting Scanline Header";
    }

    on %done {
        print self;
        # print self.scanline_header_len;
        # print self.scanline_counter;
        print "\n";
    }
};


public type br24_rep = unit {
    %port = 6679/udp &originator;

    report_type : uint8 &byte-order=spicy::ByteOrder::Little;
    command : uint8 &byte-order=spicy::ByteOrder::Little;
    

    status : br24_report_status if (self.report_type == 1);

    settings : br24_report_settings if (self.report_type == 2);

    on %init {
        print "Starting REP";
    }

    on %done {
        # print self;
    }
};

type br24_report_status = unit {
    
    status: uint8 &byte-order=spicy::ByteOrder::Little &convert=radar_status($$);
    unknown: bytes &size=(15);

    on %init {
        print "Starting REP Status";
    }

    on %done {
        print self;
    }
};

type br24_report_settings = unit {
    
    on %init {
        print "Starting REP Settings";
    }

    on %done {
        print self;
    }
};